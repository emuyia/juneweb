"""Add Role model and update User model

Revision ID: a0d7ace42393
Revises: 536302bc312c
Create Date: 2024-02-22 04:31:23.600572

"""

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = "a0d7ace42393"
down_revision = "536302bc312c"
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    role_table = op.create_table(
        "role",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("name", sa.String(length=50), nullable=True),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("name"),
    )

    # Manually add the insert commands for 'Role' data
    op.bulk_insert(
        role_table,
        [
            {"name": "User"},
            {"name": "Moderator"},
            {"name": "Admin"},
        ],
    )

    # Add 'role_id' column and foreign key before updating the 'user' table
    with op.batch_alter_table("user", schema=None) as batch_op:
        batch_op.add_column(sa.Column("role_id", sa.Integer(), nullable=True))
        batch_op.create_foreign_key("fk_user_role", "role", ["role_id"], ["id"])

    # Fetch the ID of the 'User' and 'Admin' roles
    conn = op.get_bind()
    user_role_id = conn.execute(
        sa.text("SELECT id FROM role WHERE name = 'User'")
    ).scalar()
    admin_role_id = conn.execute(
        sa.text("SELECT id FROM role WHERE name = 'Admin'")
    ).scalar()

    # Update existing users to have the 'User' role
    conn.execute(
        sa.text(
            'UPDATE "user" SET role_id = :user_role_id WHERE role_id IS NULL'
        ).bindparams(user_role_id=user_role_id)
    )

    # Update the 'user' table, setting 'role_id' to the 'Admin' role ID for users previously marked as admins
    conn.execute(
        sa.text(
            'UPDATE "user" SET role_id = :admin_role_id WHERE is_admin = True'
        ).bindparams(admin_role_id=admin_role_id)
    )

    # Drop the 'is_admin' column after updating 'role_id'
    with op.batch_alter_table("user", schema=None) as batch_op:
        batch_op.drop_column("is_admin")

    # Set the 'role_id' column to be non-nullable now that all users have a role
    with op.batch_alter_table("user", schema=None) as batch_op:
        batch_op.alter_column("role_id", nullable=False)
    # ### end Alembic commands ###


def downgrade():
    # Revert 'role_id' column to be nullable
    with op.batch_alter_table("user", schema=None) as batch_op:
        batch_op.alter_column("role_id", nullable=True)

    # Add back the 'is_admin' column to the 'user' table
    with op.batch_alter_table("user", schema=None) as batch_op:
        batch_op.add_column(sa.Column("is_admin", sa.Boolean(), nullable=True))

    # Fetch the 'User' and 'Admin' role IDs
    conn = op.get_bind()
    user_role_id = conn.execute(
        sa.text("SELECT id FROM role WHERE name = 'User'")
    ).scalar()
    admin_role_id = conn.execute(
        sa.text("SELECT id FROM role WHERE name = 'Admin'")
    ).scalar()

    # Set 'is_admin' to True where 'role_id' corresponds to 'Admin' role
    conn.execute(
        sa.text(
            'UPDATE "user" SET is_admin = True WHERE role_id = :admin_role_id'
        ).bindparams(admin_role_id=admin_role_id)
    )

    # Remove the 'role_id' column
    with op.batch_alter_table("user", schema=None) as batch_op:
        batch_op.drop_column("role_id")

    # Drop the 'role' table
    op.drop_table("role")
